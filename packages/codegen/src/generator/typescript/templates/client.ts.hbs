import { FetchClient, FetchError } from '@blimu/fetch';
import {
  type FetchClientConfig{{#if (hasBearerScheme IR.securitySchemes)}},
  type BearerAuthStrategy{{/if}}{{#if (hasApiKeyScheme IR.securitySchemes)}},
  type ApiKeyAuthStrategy{{/if}}
} from '@blimu/fetch';
import { buildAuthStrategies } from './auth-strategies';
{{#each IR.services}}
import { {{serviceName tag}} } from './services/{{fileBase tag}}';
{{/each}}

export type ClientOption = FetchClientConfig & {
  {{#each IR.securitySchemes}}
  {{#if (eq this.type "http")}}
  {{#if (eq this.scheme "bearer")}}
  {{camel this.key}}?: BearerAuthStrategy['token'];
  {{else if (eq this.scheme "basic")}}
  {{camel this.key}}?: { username: string; password: string };
  {{/if}}
  {{else if (eq this.type "apiKey")}}
  {{camel this.key}}?: ApiKeyAuthStrategy['key'];
  {{/if}}
  {{/each}}
};
{{setVar "grouped" (groupByNamespace IR.services)}}
{{! Generate namespace classes for non-root services }}
{{#each (groupByNamespace IR.services) as |services namespace|}}
  {{#if (ne namespace "")}}
class {{pascal namespace}}Namespace {
    {{#each services}}
  readonly {{serviceProp (getServiceName tag)}}: {{serviceName tag}};
    {{/each}}

  constructor(core: FetchClient) {
    {{#each services}}
    this.{{serviceProp (getServiceName tag)}} = new {{serviceName tag}}(core);
    {{/each}}
  }
}
  {{/if}}
{{/each}}
export class {{Client.name}} {
  {{! Root level services (no namespace) }}
  {{#each (getRootServices IR.services)}}
  readonly {{serviceProp tag}}: {{serviceName tag}};
  {{/each}}
  {{! Namespace properties }}
  {{#each (groupByNamespace IR.services) as |services namespace|}}
    {{#if (ne namespace "")}}
  readonly {{serviceProp namespace}}: {{pascal namespace}}Namespace;
    {{/if}}
  {{/each}}

  constructor(options?: ClientOption) {
    const restCfg = { ...(options || {}) };
    {{#each IR.securitySchemes}}
    delete restCfg.{{camel this.key}};
    {{/each}}

    const authStrategies = buildAuthStrategies(options || {});
    
    const core = new FetchClient({
      ...restCfg,
      baseURL: options?.baseURL ?? '{{Client.defaultBaseURL}}',
      ...(authStrategies.length > 0 ? { authStrategies } : {}),
    });
    
    {{! Initialize root services }}
    {{#each (getRootServices IR.services)}}
    this.{{serviceProp tag}} = new {{serviceName tag}}(core);
    {{/each}}
    {{! Initialize namespaces }}
    {{#each (groupByNamespace IR.services) as |services namespace|}}
      {{#if (ne namespace "")}}
    this.{{serviceProp namespace}} = new {{pascal namespace}}Namespace(core);
      {{/if}}
    {{/each}}
  }
}

// Re-export FetchError for backward compatibility
export { FetchError };
export const {{Client.name}}Error = FetchError;
