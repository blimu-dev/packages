import { parseSSEStream, parseNDJSONStream } from "@blimu/fetch";

export type PaginableQuery = { limit?: number; offset?: number } & Record<string, unknown>;

export async function* paginate<T>(
  fetchPage: (query?: PaginableQuery, init?: Omit<RequestInit, 'method' | 'body'>) => Promise<{ data?: T[]; hasMore?: boolean; limit?: number; offset?: number }>,
  initialQuery: PaginableQuery = {},
  pageSize = 100,
): AsyncGenerator<T, void, unknown> {
  let offset = Number(initialQuery.offset ?? 0);
  const limit = Number(initialQuery.limit ?? pageSize);
  // shallow copy to avoid mutating caller
  const baseQuery: PaginableQuery = { ...initialQuery };
  while (true) {
    const page = await fetchPage({ ...baseQuery, limit, offset });
    const items = page.data ?? [];
    for (const item of items) {
      yield item;
    }
    if (!page.hasMore || items.length < limit) break;
    offset += limit;
  }
}

export async function listAll<T>(
  fetchPage: (query?: PaginableQuery, init?: Omit<RequestInit, 'method' | 'body'>) => Promise<{ data?: T[]; hasMore?: boolean; limit?: number; offset?: number }>,
  query: PaginableQuery = {},
  pageSize = 100,
): Promise<T[]> {
  const out: T[] = [];
  for await (const item of paginate<T>(fetchPage, query, pageSize)) out.push(item);
  return out;
}

/**
 * Filters out undefined values from an array while preserving type safety
 * Useful for query keys where optional parameters might be undefined
 * Preserves tuple types when no undefined values are present
 */
export function isNotUndefined<T extends readonly unknown[]>(arr: T): T {
  // Type assertion: when no undefined values exist, tuple is preserved
  // When undefined values exist, they are filtered but type system can't infer exact tuple shape
  return arr.filter(
    (item): item is Exclude<T[number], undefined> => item !== undefined
  ) as unknown as T;
}

// Re-export streaming parsers from @blimu/fetch
export { parseSSEStream, parseNDJSONStream };
